Great question. Since we've standardized things, you now have two robust ways to access the project root in your Python scripts, and you should use them in this order of preference:

### 1\. The Environment Variable (Best for Runtime)

Since 

env_setter.ps1 (or your cloud environment configuration) sets 

```
$env:PROJECT_ROOT
```

, your Python code can simply grab it:

python

import os

from pathlib import Path

# Guaranteed way if env is set correctly

project_root = Path(os.environ['PROJECT_ROOT'])

-   Why use this? It's explicit. In AWS Lambda or SageMaker, you will set this env var in the configuration, so the code behaves identically everywhere.

### 2\. Relative Path (Best for "Just Works" Fallback)

If for some reason the environment variable isn't set (e.g. you opened the script directly in an IDE without running 

```
env_setter
```

), we can calculate it relative to the file itself. This is what we were doing before, but now we can make it a robust fallback logic in config.py.

### How src/utils/config.py does it (The Centralized Way)

You shouldn't actually need to recalculate 

```
project_root
```

 in every single script anymore. Instead, rely on config.py to do the heavy lifting for you.

Here is how 

src/utils/config.py works (or should be updated to work optimally):

python

# In src/utils/config.py

# 1. Try env var first

if  'PROJECT_ROOT'  in os.environ:

 PROJECT_ROOT = Path(os.environ['PROJECT_ROOT'])

else:

  # 2. Fallback: calculate relative to this file (config.py is in src/utils/)

  # So parents[2] takes us: src/utils/config.py -> src/utils/ -> src/ -> PROJECT_ROOT

 PROJECT_ROOT = Path(__file__).resolve().parents[2]

### So, in your new scripts (like Module 02, etc.), you just do this:

python

from src.utils.config import PROJECT_ROOT

# Now you can use it confidently:

data_path = PROJECT_ROOT /  "data"  /  "raw"

This effectively abstracts the "how" away from your business logic. The script doesn't care if it's an env var or a relative path calculation; it just imports the constant.

---


### Lessons Learned – Import & Environment Resolution Pitfalls

Here are the **key lessons** we can document (and apply to all future modules) to avoid repeating these import/environment-related blockers. These are the most common friction points when building Python projects with subpackages (`src/`, `utils/`, etc.).

| # | Lesson | Root Cause | How We Fixed It | Prevention for Next Modules |
|---|--------|------------|-----------------|-----------------------------|
| 1 | Never assume relative imports (`from utils...`) work without proper PYTHONPATH or sys.path adjustment | Python looks for packages in `sys.path` — `src/utils` is not automatically discoverable when running from project root | Used `env_setter.ps1` → sets `PYTHONPATH = C:\pyproj\AWS-CapacityForecaster` + `PROJECT_ROOT` env var | - Always run `.\env_setter.ps1` first in new PowerShell sessions<br>- Every module should either:<br>  a) Rely on `PYTHONPATH` (preferred)<br>  b) Use explicit `from src.utils...` imports (safe)<br>  c) Have minimal sys.path fallback only if env not set |
| 2 | Do **not** duplicate sys.path manipulation in every module | Multiple conflicting sys.path.insert calls cause confusion and can break when env is set | Removed manual sys.path from module_02, trusted env_setter | - Centralize path logic in one place: `env_setter.ps1` + `src/utils/config.py`<br>- Modules should **never** modify sys.path unless explicitly testing standalone |
| 3 | Function names in shared utils must match exactly what callers expect | ImportError because `load_from_s3_or_local` and `save_processed_data` did not exist in `data_utils.py` | Added the missing wrappers to `src/utils/data_utils.py` | - Before writing a module, **verify** the signature of any utility function you plan to call<br>- If missing → extend `data_utils.py` **first** (commit it) |
| 4 | S3/local duality must be implemented symmetrically in utilities | Early code assumed bidirectional wrappers existed → led to temporary hacks | Created `load_from_s3_or_local` and `save_to_s3_or_local` in utils | - Treat I/O as a **single concern** → all save/load logic lives in `data_utils.py`<br>- Future modules call these two functions only (never pd.read_parquet or boto3 directly) |
| 5 | Config-driven filenames vs defaults can cause silent failures | Hard-coded filename worked, but if date range changes → module_02 fails to find file | Used config fallback + explicit filename for now | - Make filename generation **centralized** (e.g. function in config or data_utils that computes expected name from start/end dates)<br>- Add config key `data_generation.output_filename_pattern` for consistency |
| 6 | Temporary helpers in modules become tech debt quickly | Added `simple_save_local_or_s3` in module_02 → duplicate logic | Moved save/load logic to `data_utils.py` | - **Rule**: If a function is used by >1 module → put it in `utils/data_utils.py` immediately<br>- Avoid "temporary" code in business modules |
| 7 | Run command consistency is critical for developer experience | `python src/...` vs `python -m src...` behaves differently w.r.t. package resolution | Standardized on `python -m src.modules.module_XX...` | - Document in README and every module header: "Run with `python -m src.modules.module_XX` after activating env" |

### Recommended Actions to Institutionalize These Lessons

1. **Update README.md** (quick section addition)

   ```markdown
   ### Development Setup & Run Commands

   1. Always start PowerShell session with:
      ```powershell
      .\env_setter.ps1
      ```
      → Sets PROJECT_ROOT and PYTHONPATH correctly

   2. Run any module as:
      ```powershell
      python -m src.modules.module_01_data_generation --env local
      python -m src.modules.module_02_data_load --env local
      ```

   3. Never run with `python src/modules/...py` directly — package resolution breaks.
   ```

2. **Add a small checklist** to future module design docs (in my_Docs)

   ```markdown
   ## Pre-Implementation Checklist
   - [ ] Ran `.\env_setter.ps1` in current shell?
   - [ ] `src/__init__.py` and `src/utils/__init__.py` exist?
   - [ ] All called functions exist in `src/utils/data_utils.py` or `src/utils/config.py`?
   - [ ] Imports use `from src.utils...` or rely on PYTHONPATH?
   ```

3. **Next module rule**: When we write module_03_etl_feature_eng.py, **first** verify/extend `data_utils.py` if any new I/O needed.

With these in place, we should eliminate 90% of future import/path pain.
