# 00001.config.py.md - Configuration Management Module

**Component**: src/utils/config.py  
**Version**: 1.0  
**Date**: January 18, 2026  
**Author**: Sean Girgis  

## Purpose
`src/utils/config.py` serves as the centralized, single source of truth for all configurable parameters in **AWS-CapacityForecaster**.  
It loads structured settings from `config/config.yaml` and overlays sensitive or environment-specific overrides from `.env` files.

This design achieves:
- Elimination of hard-coded values across the entire codebase
- Easy switching between local development, SageMaker notebooks, SageMaker jobs, and Lambda execution
- Secure handling of AWS credentials/role ARNs (never committed)
- Early validation of critical parameters
- Improved maintainability and onboarding for future contributors

## Key Design Principles
- **Zero hard-coding** – All tunable values (data scale, ML hyperparameters, AWS resources, risk thresholds) live in YAML
- **Layered overrides** – YAML → .env → runtime environment (SageMaker/Lambda)
- **Fail-fast validation** – Detect missing or invalid config at import time
- **Type safety & documentation** – Use typing hints and docstrings
- **Minimal dependencies** – Only `pyyaml` + `python-dotenv` (both already in requirements.txt)

## Functionality

### Main Exported Object
```python
CONFIG: Dict[str, Any]
```
Global dictionary loaded once on module import.  
All other modules access configuration via `from src.utils.config import CONFIG`

Example usage:
```python
from src.utils.config import CONFIG

NUM_SERVERS = CONFIG['data']['num_servers']
BUCKET = CONFIG['aws']['bucket_name']
FORECAST_HORIZON = CONFIG['ml']['forecast_horizon_months']
```

### Core Functions

| Function                          | Purpose                                                                 | Inputs                                 | Outputs                     | Raises                          |
|-----------------------------------|-------------------------------------------------------------------------|----------------------------------------|-----------------------------|---------------------------------|
| `load_config()`                   | Primary loader: reads YAML + applies .env overrides + validates         | None (uses default path)               | Dict[str, Any]              | FileNotFoundError, ValueError, YAMLError |
| `get_nested(d, keys, default)`    | Safe nested dictionary accessor (dot-notation helper)                  | dict, list[str], optional default      | Any                         | None                            |
| `validate_config(config)`         | Internal: checks required keys, types, reasonable ranges                | dict                                   | None                        | ValueError                      |

### Loading Sequence (on module import)
1. `load_dotenv()` – loads `.env` if present
2. Locate `config/config.yaml` relative to project root
3. `yaml.safe_load()` → config dict
4. Apply overrides from environment variables (e.g., `AWS_ROLE_ARN`, `AWS_BUCKET_NAME`)
5. Run basic validation (required keys, positive integers, valid AWS region, etc.)
6. Assign to global `CONFIG`

### Validation Rules (non-exhaustive)
- `data.num_servers` > 0
- `ml.forecast_horizon_months` ∈ [1, 12]
- `aws.region` is valid AWS region (us-east-1, etc.)
- `aws.bucket_name` is non-empty string
- `ml.models` contains at least one enabled model

## Testing Strategy

### Unit Tests Location
`tests/test_config.py`

### Test Cases (Recommended Coverage)

| Test Name                              | Description                                                  | Expected Outcome                              |
|----------------------------------------|--------------------------------------------------------------|-----------------------------------------------|
| `test_load_valid_config`               | Loads sample valid YAML                                      | Returns dict with expected structure/values   |
| `test_missing_yaml_file`               | YAML file deleted                                            | Raises FileNotFoundError with clear message   |
| `test_invalid_yaml_syntax`             | Corrupt YAML                                                 | Raises ValueError                             |
| `test_env_override`                    | Set `AWS_ROLE_ARN` in env                                    | `CONFIG['aws']['sagemaker_role_arn']` matches |
| `test_missing_required_key`            | YAML without `aws.bucket_name`                               | Raises ValueError                             |
| `test_negative_num_servers`            | `data.num_servers: -5`                                       | Raises ValueError                             |
| `test_get_nested_helper`               | Nested access with missing keys                              | Returns default without KeyError              |

### Run Tests
```powershell
pytest tests/test_config.py -v
# Or with coverage:
pytest --cov=src/utils/config tests/test_config.py
```

**Target Coverage**: ≥ 95% (lines & branches)

## Success Criteria
1. **Correctness**  
   - All scripts/notebooks using `CONFIG` receive expected values  
   - Environment overrides work reliably in SageMaker Studio, Processing Jobs, and local runs

2. **Robustness**  
   - Early failure with meaningful messages when config is broken  
   - No runtime surprises (all important params checked at startup)

3. **Maintainability**  
   - Adding new parameters requires only YAML update + optional validation rule  
   - Code remains <150 lines, highly readable

4. **Security**  
   - No secrets ever appear in committed code  
   - `.env` is in `.gitignore`

5. **Performance**  
   - Module import time < 50ms (negligible impact)

## Maintenance Notes
- When adding new sections to `config.yaml`, update:
  - Validation rules in `validate_config()`
  - Corresponding test cases
- Prefer explicit overrides via env vars for CI/CD, SageMaker, and Lambda
- Consider future migration to `pydantic-settings` if config complexity grows significantly

This module is foundational — every pipeline component depends on it.  
Keep it clean, well-tested, and boringly reliable.

Next suggested step: Implement the actual `src/utils/config.py` code based on this design.
Would you like me to provide the full code implementation now?

